use crate::*;
use oapp::endpoint_cpi::{get_accounts_for_clear_compose, LzAccount};
use oapp::{endpoint::ID as ENDPOINT_ID, LzComposeParams};

/// LzComposeTypes instruction provides a list of accounts that are used in the LzCompose
/// instruction. The list of accounts required by this LzComposeTypes instruction can be found
/// from the specific PDA account that is generated by the LZ_COMPOSE_TYPES_SEED.
#[derive(Accounts)]
pub struct LzComposeTypes<'info> {
    #[account(seeds = [COUNT_SEED, &count.id.to_be_bytes()], bump = count.bump)]
    pub count: Account<'info, Count>,
}

impl LzComposeTypes<'_> {
    /// The list of accounts should follow the rules below:
    /// 1. Include all the accounts that are used in the LzCompose instruction, including the
    /// accounts that are used by the Endpoint program.
    /// 2. Set the account is a signer with ZERO address if the LzCompose instruction needs a payer
    /// to pay fee, like rent.
    /// 3. Set the account is writable if the LzCompose instruction needs to modify the account.
    pub fn apply(
        ctx: &Context<LzComposeTypes>,
        params: &LzComposeParams,
    ) -> Result<Vec<LzAccount>> {
        let mut accounts = vec![
            // count
            LzAccount { pubkey: ctx.accounts.count.key(), is_signer: false, is_writable: true },
        ];

        let accounts_for_composing = get_accounts_for_clear_compose(
            ENDPOINT_ID,
            &params.from,
            &ctx.accounts.count.key(), // self
            &params.guid,
            params.index,
            &params.message,
        );

        accounts.extend(accounts_for_composing);

        Ok(accounts)
    }
}
