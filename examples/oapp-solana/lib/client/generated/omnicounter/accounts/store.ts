/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/kinobi-so/kinobi
 */

import {
    Account,
    Context,
    Pda,
    PublicKey,
    RpcAccount,
    RpcGetAccountOptions,
    RpcGetAccountsOptions,
    assertAccountExists,
    deserializeAccount,
    gpaBuilder,
    publicKey as toPublicKey,
} from '@metaplex-foundation/umi'
import {
    Serializer,
    bool,
    bytes,
    mapSerializer,
    publicKey as publicKeySerializer,
    string,
    struct,
    u64,
    u8,
} from '@metaplex-foundation/umi/serializers'

export type Store = Account<StoreAccountData>

export type StoreAccountData = {
    discriminator: Uint8Array
    admin: PublicKey
    composedCount: bigint
    bump: number
    endpointProgram: PublicKey
    orderedNonce: boolean
    string: string
}

export type StoreAccountDataArgs = {
    admin: PublicKey
    composedCount: number | bigint
    bump: number
    endpointProgram: PublicKey
    orderedNonce: boolean
    string: string
}

export function getStoreAccountDataSerializer(): Serializer<StoreAccountDataArgs, StoreAccountData> {
    return mapSerializer<StoreAccountDataArgs, any, StoreAccountData>(
        struct<StoreAccountData>(
            [
                ['discriminator', bytes({ size: 8 })],
                ['admin', publicKeySerializer()],
                ['composedCount', u64()],
                ['bump', u8()],
                ['endpointProgram', publicKeySerializer()],
                ['orderedNonce', bool()],
                ['string', string()],
            ],
            { description: 'StoreAccountData' }
        ),
        (value) => ({
            ...value,
            discriminator: new Uint8Array([130, 48, 247, 244, 182, 191, 30, 26]),
        })
    ) as Serializer<StoreAccountDataArgs, StoreAccountData>
}

export function deserializeStore(rawAccount: RpcAccount): Store {
    return deserializeAccount(rawAccount, getStoreAccountDataSerializer())
}

export async function fetchStore(
    context: Pick<Context, 'rpc'>,
    publicKey: PublicKey | Pda,
    options?: RpcGetAccountOptions
): Promise<Store> {
    const maybeAccount = await context.rpc.getAccount(toPublicKey(publicKey, false), options)
    assertAccountExists(maybeAccount, 'Store')
    return deserializeStore(maybeAccount)
}

export async function safeFetchStore(
    context: Pick<Context, 'rpc'>,
    publicKey: PublicKey | Pda,
    options?: RpcGetAccountOptions
): Promise<Store | null> {
    const maybeAccount = await context.rpc.getAccount(toPublicKey(publicKey, false), options)
    return maybeAccount.exists ? deserializeStore(maybeAccount) : null
}

export async function fetchAllStore(
    context: Pick<Context, 'rpc'>,
    publicKeys: Array<PublicKey | Pda>,
    options?: RpcGetAccountsOptions
): Promise<Store[]> {
    const maybeAccounts = await context.rpc.getAccounts(
        publicKeys.map((key) => toPublicKey(key, false)),
        options
    )
    return maybeAccounts.map((maybeAccount) => {
        assertAccountExists(maybeAccount, 'Store')
        return deserializeStore(maybeAccount)
    })
}

export async function safeFetchAllStore(
    context: Pick<Context, 'rpc'>,
    publicKeys: Array<PublicKey | Pda>,
    options?: RpcGetAccountsOptions
): Promise<Store[]> {
    const maybeAccounts = await context.rpc.getAccounts(
        publicKeys.map((key) => toPublicKey(key, false)),
        options
    )
    return maybeAccounts
        .filter((maybeAccount) => maybeAccount.exists)
        .map((maybeAccount) => deserializeStore(maybeAccount as RpcAccount))
}

export function getStoreGpaBuilder(context: Pick<Context, 'rpc' | 'programs'>) {
    const programId = context.programs.getPublicKey('omnicounter', 'HFyiETGKEUS9tr87K1HXmVJHkqQRtw8wShRNTMkKKxay')
    return gpaBuilder(context, programId)
        .registerFields<{
            discriminator: Uint8Array
            admin: PublicKey
            composedCount: number | bigint
            bump: number
            endpointProgram: PublicKey
            orderedNonce: boolean
            string: string
        }>({
            discriminator: [0, bytes({ size: 8 })],
            admin: [8, publicKeySerializer()],
            composedCount: [40, u64()],
            bump: [48, u8()],
            endpointProgram: [49, publicKeySerializer()],
            orderedNonce: [81, bool()],
            string: [82, string()],
        })
        .deserializeUsing<Store>((account) => deserializeStore(account))
        .whereField('discriminator', new Uint8Array([130, 48, 247, 244, 182, 191, 30, 26]))
}
