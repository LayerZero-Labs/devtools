/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/kinobi-so/kinobi
 */

import {
    Account,
    Context,
    Pda,
    PublicKey,
    RpcAccount,
    RpcGetAccountOptions,
    RpcGetAccountsOptions,
    assertAccountExists,
    deserializeAccount,
    gpaBuilder,
    publicKey as toPublicKey,
} from '@metaplex-foundation/umi'
import { Serializer, bytes, mapSerializer, struct, u8 } from '@metaplex-foundation/umi/serializers'
import { EnforcedOptions, EnforcedOptionsArgs, getEnforcedOptionsSerializer } from '../types'

export type PeerConfig = Account<PeerConfigAccountData>

export type PeerConfigAccountData = {
    discriminator: Uint8Array
    peerAddress: Uint8Array
    enforcedOptions: EnforcedOptions
    bump: number
}

export type PeerConfigAccountDataArgs = {
    peerAddress: Uint8Array
    enforcedOptions: EnforcedOptionsArgs
    bump: number
}

export function getPeerConfigAccountDataSerializer(): Serializer<PeerConfigAccountDataArgs, PeerConfigAccountData> {
    return mapSerializer<PeerConfigAccountDataArgs, any, PeerConfigAccountData>(
        struct<PeerConfigAccountData>(
            [
                ['discriminator', bytes({ size: 8 })],
                ['peerAddress', bytes({ size: 32 })],
                ['enforcedOptions', getEnforcedOptionsSerializer()],
                ['bump', u8()],
            ],
            { description: 'PeerConfigAccountData' }
        ),
        (value) => ({
            ...value,
            discriminator: new Uint8Array([181, 157, 86, 198, 33, 193, 94, 203]),
        })
    ) as Serializer<PeerConfigAccountDataArgs, PeerConfigAccountData>
}

export function deserializePeerConfig(rawAccount: RpcAccount): PeerConfig {
    return deserializeAccount(rawAccount, getPeerConfigAccountDataSerializer())
}

export async function fetchPeerConfig(
    context: Pick<Context, 'rpc'>,
    publicKey: PublicKey | Pda,
    options?: RpcGetAccountOptions
): Promise<PeerConfig> {
    const maybeAccount = await context.rpc.getAccount(toPublicKey(publicKey, false), options)
    assertAccountExists(maybeAccount, 'PeerConfig')
    return deserializePeerConfig(maybeAccount)
}

export async function safeFetchPeerConfig(
    context: Pick<Context, 'rpc'>,
    publicKey: PublicKey | Pda,
    options?: RpcGetAccountOptions
): Promise<PeerConfig | null> {
    const maybeAccount = await context.rpc.getAccount(toPublicKey(publicKey, false), options)
    return maybeAccount.exists ? deserializePeerConfig(maybeAccount) : null
}

export async function fetchAllPeerConfig(
    context: Pick<Context, 'rpc'>,
    publicKeys: Array<PublicKey | Pda>,
    options?: RpcGetAccountsOptions
): Promise<PeerConfig[]> {
    const maybeAccounts = await context.rpc.getAccounts(
        publicKeys.map((key) => toPublicKey(key, false)),
        options
    )
    return maybeAccounts.map((maybeAccount) => {
        assertAccountExists(maybeAccount, 'PeerConfig')
        return deserializePeerConfig(maybeAccount)
    })
}

export async function safeFetchAllPeerConfig(
    context: Pick<Context, 'rpc'>,
    publicKeys: Array<PublicKey | Pda>,
    options?: RpcGetAccountsOptions
): Promise<PeerConfig[]> {
    const maybeAccounts = await context.rpc.getAccounts(
        publicKeys.map((key) => toPublicKey(key, false)),
        options
    )
    return maybeAccounts
        .filter((maybeAccount) => maybeAccount.exists)
        .map((maybeAccount) => deserializePeerConfig(maybeAccount as RpcAccount))
}

export function getPeerConfigGpaBuilder(context: Pick<Context, 'rpc' | 'programs'>) {
    const programId = context.programs.getPublicKey('myOapp', 'HFyiETGKEUS9tr87K1HXmVJHkqQRtw8wShRNTMkKKxay')
    return gpaBuilder(context, programId)
        .registerFields<{
            discriminator: Uint8Array
            peerAddress: Uint8Array
            enforcedOptions: EnforcedOptionsArgs
            bump: number
        }>({
            discriminator: [0, bytes({ size: 8 })],
            peerAddress: [8, bytes({ size: 32 })],
            enforcedOptions: [40, getEnforcedOptionsSerializer()],
            bump: [null, u8()],
        })
        .deserializeUsing<PeerConfig>((account) => deserializePeerConfig(account))
        .whereField('discriminator', new Uint8Array([181, 157, 86, 198, 33, 193, 94, 203]))
}
